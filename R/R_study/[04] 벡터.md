# 벡터



## 개요

- 벡터(Vector)는 다른 프로그래밍 언어에서 흔히 접하는 배열의 개념

- 한 가지 스칼라 데이터 타입의 데이터를 저장할 수 있다.

  예를 들어, 숫자만 저장하는 배열, 문자열만 저장하는 배열이 벡터에 해당한다.

- R의 벡터는 슬라이스Slice를 제공한다.

  슬라이스란 배열의 일부를 잘라낸 뒤 이를 또 다시 배열처럼 다루는 개념을 뜻한다.

- 벡터의 각 셀에는 이름을 부여할 수 있다.

  따라서 벡터에 저장된 요소들을 색인을 사용하여 접근하는 것뿐 아니라 이름을 사용해서도 접근할 수 있다. 이런 특징을 사용하면 데이터를 좀 더 의미 있는 형태로 저장할 수 있다.







## 벡터 생성

벡터는 c( )를 사용해 생성하고, names( )를 사용해 이름을 부여할 수 있다.

| **c : 주어진 값들을 모아 벡터를 생성한다.**                  |
| ------------------------------------------------------------ |
| **`c(   ...  # 벡터로 모을 R 객체들 )`반환 값은 벡터다.**    |
| **names : 객체의 이름을 반환한다.**                          |
| **`names(   x  # 이름을 얻어올 R 객체  )`반환 값은 x와 같은 길이의 문자열 벡터 또는 NULL이다.** |
| **names<- : 객체에 이름을 저장한다.**                        |
| **`names(   x          # 이름을 저장할 R 객체  ) <- value # 저장할 이름`** |



### c( ) 를 사용하여 벡터 생성

- 벡터는 c( ) 안에 값을 나열하는 방법으로 생성한다.

  다음 코드에서 x <- c(…) 부분이 다시 괄호 안에 쌓여 있음에 주목하기 바란다. 이렇게 괄호로 코드를 묶으면 괄호 안의 문장을 수행하고 그 결과 값을 다시 화면에 출력한다.

  ```R
  > ( x <- c(1, 2, 3, 4, 5) )
  
  [1] 1 2 3 4 5
  ```



### 벡터 생성 규칙/타입

- 나열하는 인자들은 벡터의 정의대로 한 가지 유형의 스칼라 타입이어야 한다.

- 만일 서로 다른 타입의 데이터를 섞어서 벡터에 저장하면, 이들 데이터는 한 가지 타입으로 자동 형 변환된다.

  이때 사용되는 형 변환 규칙은 좀 더 표현력이 높은 데이터 타입으로 변환하는 것이다.

  정확한 변환 규칙은 NULL < raw < logical < integer < double < complex < character < list < expression 순서다.

  예를 들어, 정수와 부동소수가 섞여 있다면 모두 부동소수로 변환되며, 정수와 문자열이 섞여 있다면 모두 문자열로 변환된다. 

  아래 코드에서 숫자형 데이터인 2는 “2”라는 문자열 형태로 자동으로 변환되어 x 안에는 문자열 형태의 데이터만 나열된다.

  ```R
  > (x <- c("1", 2, "3"))
  
  [1] "1" "2" "3"
  ```

- 그러나 이런 형 변환 규칙을 모두 기억할 필요는 없다. 만약 서로 다른 데이터 타입으로 된 데이터를 다루고 싶다면 '리스트'를 사용하고, 벡터에서는 늘 한 가지 데이터 타입만 사용하는 편이 낫다.

### 벡터의 중첩 가능 여부

벡터는 중첩할 수 없다. 따라서 벡터 안에 벡터를 생성하면 단일 차원의 벡터로 변경된다.

중첩된 구조가 필요하다면 역시 리스트를 사용해야 한다.

```R
> c(1, 2, 3)
[1] 1 2 3

> c( 1, 2, 3, c(1, 2, 3) )
[1] 1 2 3 1 2 3
```

연속된 숫자를 저장하는 벡터는 자주 사용되기 때문에 1, 2, 3, …과 같은 값을 저장한 벡터를 손쉽게 생성하는 별도의 문법이 있다. 이에 대해서는 ‘4.4 apply 계열 함수’ 절에서 설명한다.





## 벡터 데이터 접근





### 벡터의 각 셀에 이름 부여

벡터의 각 셀에는 names<-( ) 함수를 사용해 이름을 부여할 수 있다. names( )의 반환 값에 원하는 이름을 문자열 벡터로 할당하면 된다.







## 벡터 연산

  벡터는 값을 하나씩 접근해 해당 값을 사용한 계산을 수행하거나, 벡터 전체에 대해 연산을 한 번에 수행하거나, 벡터를 집합처럼 취급해 집합 연산(합집합, 교집합, 차집합)을 계산할 수 있다.

- identical( ) 함수
- %in% 연산자

#### 

두 벡터가 같은 값을 담고 있는지는 identical( ) 함수로 알 수 있다.

```R


> identical(c(1, 2, 3), c(1, 2, 3))
[1] TRUE
> identical(c(1, 2, 3), c(1, 2, 100))
[1] FALSE
```

%in% 연산자는 어떤 값이 벡터에 포함되어 있는지를 알려준다.

```R
> "a" %in% c("a", "b", "c")
[1] TRUE
> "d" %in% c("a", "b", "c")
[1] FALSE
```

벡터 전체 값에 대한 연산을 한 번에 수행하려면 벡터를 마치 하나의 숫자처럼 생각하고 연산을 수행하면 된다. 이와 같이 데이터 전체에 대해 수행하는 연산은 R의 특징 중 하나로, 각 요소별로 연산을 수행하는 경우에 비해 실행 속도가 빠르기 때문에 자주 사용한다. 더 자세한 내용은 ‘3장. R 프로그래밍’에서 다시 알아본다.

```R
> x <- c(1, 2, 3, 4, 5)
> x + 1
[1] 2 3 4 5 6
> 10 - x
[1] 9 8 7 6 5
```

같은 방법으로 == 또는 != 연산자를 사용해 두 벡터에 저장된 값들을 한 번에 비교할 수 있다. 그러나 흔히 if 문 등의 조건문에서는 단 하나의 참 또는 거짓 값을 사용해야 하기 때문에 ==, !=가 아니라 앞서 설명한 identical( )을 사용해야 한다는 점을 기억하기 바란다. 흔히 실수하기 쉬운 부분이다.

```R
> c(1, 2, 3) == c(1, 2, 100)
[1] TRUE TRUE FALSE
> c(1, 2, 3) != c(1, 2, 100)
[1] FALSE FALSE TRUE
```



### 집합 계산 - union, intersect, setdiff

벡터를 집합Set으로 취급해 집합 간 합집합, 교집합, 차집합을 계산할 수 있다.

```R
# union : 합집합을 구한다.
union( x, y ) # x, y 는 벡터

> union ( c("a", "b", "c"), c("a", "d") )
[1] "a" "b" "c" "d"

# intersect : 교집합을 구한다.
intersect( x, y ) # x, y 는 벡터

> intersect( c("a", "b", "c"), c("a", "d") )
[1] "a"

# setdiff : 차집합을 구한다.
setdiff( x, y ) # x, y 는 벡터

> setdiff( c("a", "b", "c"), c("a", "d") )
[1] "b" "c"
```



### 집합 간 비교 - setequal

```R
# setequal : x와 y가 같은 집합인지 판단한다.
# 반환 값은 x와 y가 같은 집합인지 여부다.
setequal( x, y ) # x, y 는 벡터

> setequal (c("a", "b", "c"), c("a", "d"))
[1] FALSE
> setequal (c("a", "b", "c"), c("a", "b", "c", "c"))
[1] TRUE
```





## 연속된 숫자로 구성된 벡터



## 반복된 값을 저장한 벡터

