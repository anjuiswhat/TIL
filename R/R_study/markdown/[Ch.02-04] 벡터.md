# [Ch.02-04] 벡터



## 개요

- 벡터(Vector)는 다른 프로그래밍 언어에서 흔히 접하는 배열의 개념

- 한 가지 스칼라 데이터 타입의 데이터를 저장할 수 있다.

  예를 들어, 숫자만 저장하는 배열, 문자열만 저장하는 배열이 벡터에 해당한다.

- R의 벡터는 슬라이스(Slice)를 제공한다.

  슬라이스란 배열의 일부를 잘라낸 뒤 이를 또 다시 배열처럼 다루는 개념을 뜻한다.

- 벡터의 각 셀에는 이름을 부여할 수 있다.

  따라서 벡터에 저장된 요소들을 색인을 사용하여 접근하는 것 뿐 아니라 이름을 사용해서도 접근할 수 있다. 이런 특징을 사용하면 데이터를 좀 더 의미 있는 형태로 저장할 수 있다.



## 벡터 생성



### `c()` : 주어진 값들을 모아 벡터를 생성

- 벡터는 `c()` 안에 값을 나열하는 방법으로 생성한다. 반환 값은 벡터다.

※ 다음 코드에서 `x <- c(…)` 부분이 다시 괄호 안에 쌓여 있음에 주목하기 바란다. 이렇게 괄호로 코드를 묶으면 괄호 안의 문장을 수행하고 그 결과 값을 다시 화면에 출력한다.

```R
# c() 안에 값을 나열하는 방법으로 생성한다. 반환 값은 벡터다.

c(
   ...  # 벡터로 모을 R 객체들
)

-------------------- < example > ------------------------------

> ( x <- c(1, 2, 3, 4, 5) )
[1] 1 2 3 4 5
```



#### 벡터 생성 규칙, 타입 및 형변환 규칙

- 나열하는 인자들은 벡터의 정의대로 한 가지 유형의 스칼라 타입이어야 한다.

- 만일 서로 다른 타입의 데이터를 섞어서 벡터에 저장하면, 이들 데이터는 한 가지 타입으로 자동 형 변환된다.

- 이때 사용되는 형 변환 규칙은 좀 더 표현력이 높은 데이터 타입으로 변환하는 것이다.

- 정확한 변환 규칙은 NULL < raw < logical < integer < double < complex < character < list < expression 순서다.

  예를 들어, 정수와 부동소수가 섞여 있다면 모두 부동소수로 변환되며, 정수와 문자열이 섞여 있다면 모두 문자열로 변환된다. 

  아래 코드에서 숫자형 데이터인 2는 “2”라는 문자열 형태로 자동으로 변환되어 x 안에는 문자열 형태의 데이터만 나열된다.

- 그러나 이런 형 변환 규칙을 모두 기억할 필요는 없다. 만약 서로 다른 데이터 타입으로 된 데이터를 다루고 싶다면 '리스트'를 사용하고, 벡터에서는 늘 한 가지 데이터 타입만 사용하는 편이 낫다.

```R
> (x <- c("1", 2, "3"))
[1] "1" "2" "3"
```



#### 벡터의 중첩 가능 여부

- 벡터는 중첩할 수 없다. 따라서 벡터 안에 벡터를 생성하면 단일 차원의 벡터로 변경된다.

- 중첩된 구조가 필요하다면 역시 리스트를 사용해야 한다.
- 연속된 숫자를 저장하는 벡터는 자주 사용되기 때문에 1, 2, 3, …과 같은 값을 저장한 벡터를 손쉽게 생성하는 별도의 문법이 있다. 이에 대해서는 ‘4.4 apply 계열 함수’ 절에서 설명한다.

```R
> c(1, 2, 3)
[1] 1 2 3

> c( 1, 2, 3, c(1, 2, 3) )
[1] 1 2 3 1 2 3
```



### `names` : 벡터의 각 셀(객체)에 이름 부여 및 확인

- 벡터의 각 셀에는 `names<-()` 함수를 사용해 이름을 부여할 수 있다. `names()`의 반환 값에 출력하고 싶은 원하는 이름을 문자열 벡터로 할당하면 된다.

```R
# names<- : 객체에 이름을 저장한다.
names(
   x	# 이름을 저장할 R 객체 
) <- value	# 저장할 이름

-------------------- < example > ------------------------------

> x <- c(1,3,4)
> names(x) <- c("kim", "seo", "park")
> x
 kim  seo park 
   1    3    4 
```

- 부여한 이름을 반환할 때는 `names()` 함수를 사용한다. 반환 값은 x와 같은 길이의 문자열 벡터 또는 NULL이다.

※ `names()`는 값을 얻어오는 함수고, `names<-()`는 값을 할당하는 함수다.

```R
# names : 부여한 객체의 이름을 반환한다. 반환 값은 x와 같은 길이의 문자열 벡터 또는 NULL이다.
names(
   x  # 이름을 얻어올 R 객체 
)

-------------------- < example > ------------------------------

> x <- c(1,3,4)
> names(x) <- c("kim", "seo", "park")
> names(x)
[1] "kim"  "seo"  "park"
```



## 벡터 데이터 접근

- 벡터의 데이터를 접근하는 데는 색인을 사용하는 방법과 이름을 사용하는 방법이 있다.

- 또, 벡터에서 특정 요소를 제외한 나머지 데이터를 가져오거나, 동시에 여러 셀의 데이터를 접근하는 것 역시 가능하다. 



### 색인을 이용한 벡터 데이터 접근

- 벡터는 [ ] 안에 색인을 적어 각 요소를 가져올 수 있다. 이때, 색인은 다른 언어와 달리 1부터 시작한다.
- 또한, ‘`-색인`’ 형태로 음의 색인을 사용해 특정 요소만 제외할 수도 있다.
- 여러 위치에 저장된 값을 한 번에 가져오려면 ‘`벡터명[색인 벡터]`’ 형식을 사용한다.
- ‘`start:end`’ 형태의 문법은 `start`부터 `end`까지의 숫자를 저장한 숫자 벡터를 뜻한다. 따라서 `x[start:end]`를 사용해 `start`부터 `end`까지의 데이터(`start`와 `end`에 위치한 요소 포함)를 볼 수 있다.

```R
> x <- c("a", "b", "c")

# x[n] : 벡터 x의 n번째 요소. n은 숫자 또는 셀의 이름을 뜻하는 문자열

> x[1]
[1] "a"

> x[3]
[1] "c"


# x[-n] : 벡터 x에서 n번째 요소를 제외한 나머지. n은 숫자 또는 셀의 이름을 뜻하는 문자열

> x[-1]
[1] "b" "c"

> x[-2]
[1] "a" "c"


# x[idx_vector] : 벡터 x로부터 idx_vector에 지정된 요소를 얻어옴.
#			   이때 idx_vector는 색인을 표현하는 숫자 벡터 또는 셀의 이름을 표현하는 문자열 벡터

> x[c(1, 2)]
[1] "a" "b"

> x[c(1, 3)]
[1] "a" "c"


# x[start:end] : 벡터 x의 start부터 end까지의 값을 반환함.
#			  반환 값은 start 위치의 값과 end 위치의 값을 모두 포함함

> x[1:2]
[1] "a" "b"

> x[1:3]
[1] "a" "b" "c"
```



### 이름을 이용한 벡터 데이터 접근

- 벡터의 각 셀에 `names()<-` 를 사용해 이름을 부여했다면, 이 이름을 사용해 데이터를 접근할 수 있다.
- 벡터에 부여된 이름만 보려면 이름을 부여할 때와 마찬가지로 `names()`를 사용한다. 

```R
> x <- c(1, 3, 4)

> names(x) <- c("kim", "seo", "park")
> x
kim seo park
1 3 4

> x["seo"]
seo
3

> x[c("seo", "park")]
seo park
3 4

> names(x) [2]
[1] "seo"
```



### 벡터의 길이 확인



#### `length` : 객체의 길이를 반환

```R
length(
   x  # R 객체. 팩터, 배열, 리스트를 지정한다.
)

-------------------- < example > ------------------------------

> x <- c("a", "b", "c")
> length(x)
[1] 3
```



#### `NROW` : 배열의 행 또는 열의 수를 반환

- `NROW` 가 대문자임에 주의!!!

- 본래 `nrow()`는 행렬과 데이터 프레임의 행의 수를 알려주는 함수

- `nrow()`의 변형인 `NROW()`는 인자가 벡터인 경우 벡터를 n행 1열의 행렬로 취급해 길이를 반환한다.

- 따라서 데이터 타입에 무관하게 길이를 알고 싶은 경우 `length()`, `nrow()`, `NROW()`의 구분 없이 항상 `NROW()`만 사용하면 대부분 문제없이 동작한다.

```R
NROW(
   x  # 벡터, 배열 또는 데이터 프레임 
)

-------------------- < example > ------------------------------

> x <- c("a", "b", "c")

> nrow(x)  # nrow()는 행렬만 가능
NULL

> NROW(x)  # NROW()는 벡터와 행렬 모두 사용 가능
[1] 3
```



## 벡터 연산



### `identical()` : 두 벡터가 같은 값을 담고 있는지 확인

- 반환 값은 x와 y가 동일하면 TRUE, 그렇지 않으면 FALSE다.

```R
identical(
   x,  # R 객체 
   y   # R 객체
)

-------------------- < example > ------------------------------

> identical(c(1, 2, 3), c(1, 2, 3))
[1] TRUE

> identical(c(1, 2, 3), c(1, 2, 100))
[1] FALSE
```



### `%in%` 연산자 : 특정 값이 벡터에 포함되어 있는지 확인

```R
> "a" %in% c("a", "b", "c")
[1] TRUE

> "d" %in% c("a", "b", "c")
[1] FALSE
```



### 벡터의 전체 값에 대한 연산

- 벡터 전체 값에 대한 연산을 한 번에 수행하려면 벡터를 마치 하나의 숫자처럼 생각하고 연산을 수행하면 된다.
- 이와 같이 데이터 전체에 대해 수행하는 연산은 R의 특징 중 하나로, 각 요소별로 연산을 수행하는 경우에 비해 실행 속도가 빠르기 때문에 자주 사용한다.



#### `x + n` : 벡터 `x`의 모든 요소에 `n`을 더하는 연산

```R
> x <- c(1, 2, 3, 4, 5)

> x + 1
[1] 2 3 4 5 6

> x - 3
[1] -2 -1  0  1  2

> 10 - x
[1] 9 8 7 6 5
```



#### 두 벡터에 저장된 값들을 한번에 비교 ( == 또는 != 연산자 사용 )

[ 주의!!! ]	흔히 if 문 등의 조건문에서는 단 하나의 참 또는 거짓 값을 사용해야 하기 때문에 ==, !=가 아니라 `identical()`을 사용해야 한다. 흔히 실수하기 쉬운 부분이다.

```R
> c(1, 2, 3) == c(1, 2, 100)
[1] TRUE TRUE FALSE

> c(1, 2, 3) != c(1, 2, 100)
[1] FALSE FALSE TRUE
```



### 집합 계산

#### `union`, `intersect`, `setdiff` : 합집합, 교집합, 차집합

- 벡터를 집합Set으로 취급해 집합 간 합집합, 교집합, 차집합을 계산할 수 있다.

```R
# union : 합집합을 구한다.
union( x, y ) # x, y 는 벡터

> union ( c("a", "b", "c"), c("a", "d") )
[1] "a" "b" "c" "d"

# intersect : 교집합을 구한다.
intersect( x, y ) # x, y 는 벡터

> intersect( c("a", "b", "c"), c("a", "d") )
[1] "a"

# setdiff : 차집합을 구한다.
setdiff( x, y ) # x, y 는 벡터

> setdiff( c("a", "b", "c"), c("a", "d") )
[1] "b" "c"
```



#### `setequal` : 집합 간 비교

- x와 y가 같은 집합인지 판단한다.
- 반환 값은 x와 y가 같은 집합인지 여부다.

```R
setequal( x, y ) # x, y 는 벡터

> setequal (c("a", "b", "c"), c("a", "d"))
[1] FALSE

> setequal (c("a", "b", "c"), c("a", "b", "c", "c"))
[1] TRUE
```



## 연속된 숫자로 구성된 벡터

- 다량의 데이터가 있을 때 데이터의 일부를 한 번에 잘라서 처리하기 위해 흔히 숫자 색인 값이 저장된 벡터를 사용한다.
- 또한, 연속된 데이터를 한 번에 잘라낼 경우가 많아 연속된 숫자가 저장된 벡터가 종종 필요하다.



### `seq(from, end, by)` : 시퀀스를 생성

- `from`부터 `to`까지의 값을 `by` 간격으로 저장한 숫자 벡터를 반환한다.

- 여기서 `by`는 생략 가능하며, 이 경우 1씩 증가 또는 감소하는 것으로 자동 지정된다.

```R
seq(
  from,  # 시작 값 
  to,    # 끝 값 
  by     # 간격 설정, 생략되면 1씩 증가 또는 감소되는 것으로 자동 지정 
)

-------------------- < example > ------------------------------

> seq(3, 7)     # by 생략됨 -> 1씩 증가
[1] 3 4 5 6 7

> seq(7, 3)     # by 생략됨 -> 1씩 감소
[1] 7 6 5 4 3

> seq(3, 7, 2)  # 2씩 증가
[1] 3 5 7

> seq(3, 7, 3)  # 3씩 증가
[1] 3 6
```



#### `start:end` 형태의 축약형

- 1씩 증가 또는 감소하는 벡터의 경우 `seq()`를 사용하지 않고 `start:end` 형태의 축약형으로도 표현할 수 있다.

```R
> 3:7
[1] 3 4 5 6 7

> 7:3
[1] 7 6 5 4 3
```



### `seq_along` : 주어진 객체의 길이만큼 시퀀스를 생성

- 1부터 주어진 벡터의 길이 N 까지의 값을 저장한 색인 벡터가 필요한 경우, 다음 두 가지 방법이 있다.
  - `seq_along(x)`를 사용해 x의 길이까지의 값을 담은 벡터를 생성
  - `NROW()`로 길이를 얻어 색인 벡터를 생성

```R
seq_along(
  along.with  # 이 인자 길이만큼 시퀀스를 생성한다. 
)
반환 값은 along.with의 길이가 N일 때, 1부터 N까지의 숫자를 저장한 벡터다.

-------------------- < example > ------------------------------

> x <- c(2, 4, 6, 8, 10)

> seq_along(x)
[1] 1 2 3 4 5

> 1:NROW(x)		# NROW()를 사용해도 같은 결과가 출력된다.
[1] 1 2 3 4 5
```



## 반복된 값을 저장한 벡터

- 반복된 값을 저장한 벡터는 c(1, 1, 1, 1, 2, 2, 2, 2) 또는 c(1, 2, 1, 2, 1, 2, 1, 2)처럼 숫자가 반복되는 형태로 나타나는 벡터를 뜻한다.
- 이러한 벡터를 색인 벡터로 사용하면 주어진 데이터를 몇 개 분류로 쉽게 나눌 수 있어 종종 사용한다. 
- 반복된 값이 저장된 벡터는 `rep()`로 생성할 수 있다.



### `rep` : 주어진 값을 반복

- 반환 값은 반복된 값이 저장된 x와 같은 타입의 객체다.

```R
rep(
   x,      # 반복할 값이 저장된 벡터 
   times,  # 전체 벡터의 반복 횟수 
   each    # 개별 값의 반복 횟수 
)

-------------------- < example > ------------------------------

# 숫자 1, 2에 대해 times=5를 지정하면 1, 2의 나열이 5회 반복된다.

> rep(1:2, times=5)
[1] 1 2 1 2 1 2 1 2 1 2


# each=5를 지정하면 개별 값이 5회 반복된다. 즉, 1이 5회 반복된 후 2가 5회 반복된다.

> rep(1:2, each=5)
[1] 1 1 1 1 1 2 2 2 2 2


#each=5, times=2를 지정하면 개별 값의 5회 반복을 총 2회 반복한다.

> rep(1:2, each=5, times=2)
[1] 1 1 1 1 1 2 2 2 2 2 1 1 1 1 1 2 2 2 2 2
```
